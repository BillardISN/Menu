#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import pygame
from pygame.locals import *


class TextEntry:
    """A very simple text entry for pygame.
    The text entered can be accessed by the text attribute.
    """
    def __init__(self, font, color, **position):
        """
        font: instance of a pygame.Font object to draw the text
        color: tuple for the color of the text
        **position: position of the text entry. See pygame.Rect doc for all the possible attributes.
        """
        self.text = ""
        self.font = font
        self.color = color
        self.position = position
        self._refresh()
        self.timer = 0
        self.blink_time = 0.6
        self.carret_visible = True
        self.carret_idx_pos = 0
        self.carret_coords = (self.rect.topright, self.rect.bottomright)
        pygame.key.set_repeat(400, 50)

    def process_events(self, events):
        "Process the events passed to the text entry."
        for event in events:
            if event.type == KEYDOWN:
                if event.key == K_LEFT:
                    self.carret_idx_pos = max(0, self.carret_idx_pos-1)
                elif event.key == K_RIGHT:
                    self.carret_idx_pos = min(self.carret_idx_pos+1, len(self.text))
                elif event.key == K_BACKSPACE:
                    if self.carret_idx_pos == 0:
                        continue
                    self.carret_idx_pos = self.carret_idx_pos - 1
                    self.text = self.text[:self.carret_idx_pos] + self.text[self.carret_idx_pos+1:]
                    self._refresh()
                elif event.key == K_DELETE:
                    if self.carret_idx_pos == len(self.text):
                        continue
                    self.text = self.text[:self.carret_idx_pos] + self.text[self.carret_idx_pos+1:]
                    self._refresh()
                else:
                    self.text = self.text[:self.carret_idx_pos] + event.unicode + self.text[self.carret_idx_pos:]
                    if event.unicode:
                        self.carret_idx_pos += 1
                    self._refresh()
                self._update_carret()

    def update(self, dt):
        "Update the carret blinking with the time dt."
        self.timer += dt
        while self.timer > self.blink_time:
            self.timer -= self.blink_time
            self.carret_visible = not self.carret_visible

    def _update_carret(self):
        "Update the position of the carret."
        x_offset, y_offset = self.font.size(self.text[:self.carret_idx_pos])
        self.carret_coords = ((self.rect.x + x_offset, self.rect.top), (self.rect.x + x_offset, self.rect.bottom))

    def _refresh(self):
        "Create a new surface with the text."
        self.surface = self.font.render(self.text, True, self.color)
        self.rect = self.surface.get_rect(**self.position)

    def draw(self, surface):
        "Draw the text surface and the carret to the given surface (normally the screen surface)."
        surface.blit(self.surface, self.rect)
        if self.carret_visible:
            pygame.draw.line(surface, (255, 255, 255, 255), *self.carret_coords)

class GameStateMachine:
    "State Machine for the main game loop"
    def __init__(self, start_state):
        self.state = start_state
        self.state.game_sm = self
        self.state.on_enter()

    def change_state(self, new_state):
        self.state.on_exit()
        self.state = new_state
        self.state.game_sm = self
        self.state.on_enter()

    def __getattr__(self, name):
        "Delegate all other method calls to the actual state."
        return getattr(self.state, name)

def creer_label(font, texte, couleur, **position):
    "Creates a surface and its rectangle for a given text."
    surface = font.render(texte, True, couleur)
    rect = surface.get_rect(**position)
    return surface, rect


class State:
    """This class should not be directly instanciated.
    You should derive concrete States from this class.

    Note: I could have used a proper Abstract Base Class from the standard library.
    See doc: https://docs.python.org/3.4/library/abc.html
    """
    def __init__(self):
        self.game_sm = None

    def on_enter(self):
        pass

    def on_exit(self):
        pass

    def process_events(self, events):
        pass

    def update(self, dt):
        pass

    def draw(self, surface):
        pass


class IntroState(State):
    "Introduction state saying Hello and waiting for a key press."
    def on_enter(self):
        self.label, self.rect = creer_label(font_cambria, "Vous êtes l'équipe rouge. Pressez une touche pour continuer...",
                        ROUGE, center=fenetre_rect.center)
    def process_events(self, events):
        for event in events:
            if event.type == KEYDOWN:
                self.game_sm.change_state(AskNameState())

    def draw(self, surface):
        surface.blit(self.label, self.rect)


class AskNameState(State):
    "This state asks for the user name. Quits when return is pressed."
    def on_enter(self):
        self.label, self.label_rect = creer_label(font_cambria, "Entrez votre nom.",
                        ROUGE, topleft=(100, 100))
        self.text_entry = TextEntry(font_cambria, ROUGE, topleft=(self.label_rect.left, self.label_rect.bottom + 20))

    def process_events(self, events):
        for event in events:
            if event.type == KEYDOWN and event.key == K_RETURN:
                self.game_sm.change_state(GreetState(self.text_entry.text))
        self.text_entry.process_events(events)

    def draw(self, surface):
        surface.blit(self.label, self.label_rect)
        self.text_entry.draw(surface)

    def update(self, dt):
        self.text_entry.update(dt)

class GreetState(State):
    "This state greets a user with the given name in the __init__ method."
    def __init__(self, name):
        self.name = name
        self.labels = []

    def on_enter(self):
        label, rect = creer_label(font_cambria, "Bonjour {}!".format(self.name),
                                    ROUGE, center=fenetre_rect.center)
        self.labels.append((label, rect))
        self.labels.append(creer_label(font_cambria,
                            "Bonne chance et amusez vous bien !",
                            BLEU, center=(rect.centerx, rect.bottom + 20)))

    def draw(self, surface):
        for label, rect in self.labels:
            surface.blit(label, rect)

# On initialise pygame
pygame.init()
taille_fenetre = (800, 600)
fenetre_rect = pygame.Rect((0, 0), taille_fenetre)
screen_surface = pygame.display.set_mode(taille_fenetre)

BLANC     = (255, 255, 255)
BLEU_CIEL = (185, 240, 240)
BLEU_NUIT = (  5,   5,  30)
ROUGE     = (255,   0,   0)
MARRON    = (145,  35,  30)
NOIR      = (  0,   0,   0)
VERT      = (  0, 255,   0)
BLEU      = (  0,   0, 255)
JAUNE     = (255, 255,   0)

timer = pygame.time.Clock()

font_cambria = pygame.font.SysFont('Cambria', 24)
game_state = GameStateMachine(IntroState())

# Boucle événementielle
continuer = True
while continuer:
    events = pygame.event.get()
    for event in events:
        if event.type == QUIT or event.type == KEYDOWN and event.key == K_ESCAPE:
            continuer = False
    game_state.process_events(events)


    # En dessous de ce commentaire vient la logique du jeu
    dt = timer.tick(60) / 1000
    game_state.update(dt)


    # En dessous de ce commentaire vient l'affichage du jeu
    screen_surface.fill(NOIR)
    game_state.draw(screen_surface)

    pygame.display.flip()

pygame.quit()
