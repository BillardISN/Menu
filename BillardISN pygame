H=500
L=1000
##le personnage
class Personnage():

    def __init__(self,x,y,v,angle,ax,ay):
        self.x=x
        self.y=y
        self.cos=cos(angle)
        self.sin=sin(angle)
        self.vx=v*self.cos
        self.vy=v*self.sin
        self.ff=1/100
        self.ax=ax
        self.ay=ay
        self.dt=0.1
        self.rayon=15

        self.mur=False
        self.debout=False

    def evoluer(self):
        self.vx=self.vx+self.ax*self.dt
        self.vy=self.vy+self.ay*self.dt
        self.v=sqrt(((self.vx)**2)+((self.vy)**2))
        if self.v!=0:
            self.kff=(self.v-self.ff)/(self.v)
        if self.v>0:
            self.vx=self.kff*self.vx
            self.vy=self.kff*self.vy
        else:
            self.vx=0
            self.vy=0
        self.x=self.x+self.vx*self.dt
        self.y=self.y+self.vy*self.dt


    def afficher(self):
        print("(x,y): "+str(self.x)+","+str(self.y)+"  vx,vy: "+str(self.vx)+","+str(self.vy))

    def collision(self,obs):
        haut=(self.y+self.rayon<obs.y)
        bas=(self.y-self.rayon>obs.y+obs.ly)
        gauche=(self.x+self.rayon<obs.x)
        droite=(self.x-self.rayon>obs.x+obs.lx)
        collision=not(haut or bas or gauche or droite)
        return collision

    def contact(self,obs):
        contact=not((sqrt((obs.x-self.x)**2+((obs.y-self.y)**2)))<25)
        return contact


##un obstacle est betement un carre
class Obstacle():

    def __init__(self,dx,dy,dx1,dy1,mechant):
        self.x=dx
        self.y=dy
        self.lx=dx1
        self.ly=dy1
        self.mechant=mechant

class Cercle():

    def __init__(self,dx,dy,mechant):
        self.x=dx
        self.y=dy
        self.mechant=mechant

##un jeu est un personnage et des obstacles
class Jeu():

    def __init__(self):
        self.pj=Personnage(350,100,0,1,0,0)
        self.ba=Personnage(400,400,0,0,0,0)
        self.bb=Personnage(700,400,0,0,0,0)
        self.bc=Personnage(300,300,0,0,0,0)
        self.bd=Personnage(200,300,0,0,0,0)
        self.be=Personnage(100,300,0,0,0,0)
        self.bf=Personnage(200,200,0,0,0,0)
        self.bg=Personnage(200,100,0,0,0,0)
        self.bh=Personnage(600,300,0,0,0,0)
        self.bi=Personnage(600,100,0,0,0,0)
        self.bj=Personnage(500,400,0,0,0,0)
        self.bk=Personnage(100,400,0,0,0,0)
        self.bl=Personnage(100,200,0,0,0,0)
        self.bm=Personnage(100,100,0,0,0,0)
        self.bn=Personnage(400,300,0,0,0,0)
        self.bo=Personnage(400,100,0,0,0,0)
        self.Liste=[self.pj,self.ba,self.bb,self.bc,self.bd,self.be,self.bf,self.bg,self.bh,self.bi,self.bj,self.bk,self.bl,self.bm,self.bn,self.bo]
        self.obstacles=[]
        self.obstacles+=[Obstacle(30,60,0,H-120,False)]
        self.obstacles+=[Obstacle(L-30,60,L-30,H-120,False)]
##        self.obstacles+=[Obstacle(60,30,L-120,0,False)]
        self.obstacles+=[Obstacle(60,30,((L-120)/2)-35,0,False)]
        self.obstacles+=[Obstacle((L/2)+35,30,((L-120)/2)-35,0,False)]
##        self.obstacles+=[Obstacle(60,H-30,L-120,H-30,False)]
        self.obstacles+=[Obstacle(60,H-30,((L-120)/2)-35,H-30,False)]
        self.obstacles+=[Obstacle((L/2)+35,H-30,((L-120)/2)-35,H-30,False)]
        self.troue=[]
        self.troue+=[Cercle(25,20,True)]
        self.troue+=[Cercle(L/2,20,True)]
        self.troue+=[Cercle(975,20,True)]
        self.troue+=[Cercle(25,475,True)]
        self.troue+=[Cercle(L/2,475,True)]
        self.troue+=[Cercle(975,475,True)]

##        self.obstacles+=[Obstacle(50,400,400,50,False)]
##        self.obstacles+=[Obstacle(0,0,50,450,False)]
##        self.obstacles+=[Obstacle(450,0,50,450,False)]
##        self.obstacles+=[Obstacle(100,300,200,10,False)]
##        self.obstacles+=[Obstacle(200,180,10,70,False)]
##        self.obstacles+=[Obstacle(250,180,10,70,False)]
##        self.obstacles+=[Obstacle(250,179,100,10,False)]
##        self.obstacles+=[Obstacle(150,150,20,20,True)]


    def evoluer(self):
        global done
##        Liste=[self.pj,self.br,self.j]

        ##deplace
        self.pj.debout=False

        ##deplace le pj
        self.pj.evoluer()
        self.ba.evoluer()
        self.bb.evoluer()
        self.bc.evoluer()
        self.bd.evoluer()
        self.be.evoluer()
        self.bf.evoluer()
        self.bg.evoluer()
        self.bh.evoluer()
        self.bi.evoluer()
        self.bj.evoluer()
        self.bk.evoluer()
        self.bl.evoluer()
        self.bm.evoluer()
        self.bn.evoluer()
        self.bo.evoluer()

        ##test collision
        collision=False
        res=[]
        verification=[0]

        for balle in self.Liste:
            for obs in self.obstacles:

                if (balle.collision(obs)):
                    ##si l'obstacle est mechant
                    if (obs.mechant):
                        balle=Personnage()
                    else:
                        if(balle.y<obs.y)and(balle.y+balle.rayon>=obs.y)and (balle.vy>0):
                            ##obstacle en bas
                            balle.vy=-balle.vy
                            balle.y=obs.y-balle.rayon
                            ##le personnage est debout
                            balle.debout=True
                        else:
                            if(balle.y>obs.y+obs.ly)and(balle.y-balle.rayon<=obs.y+obs.ly):
                                ##obstacle en haut
                                balle.vy=-balle.vy
                            else:
                                if(balle.x<obs.x):
                                    ##obstacle a droite
                                    balle.vx=-balle.vx
                                if(balle.x>obs.x+obs.lx):
                                    ##obstacle en gauche
                                    balle.vx=-balle.vx

            ##détection de la collision
            Ok=1
            for obs in self.troue:
                if (balle.contact(obs))==False:
                    if (obs.mechant):
                        balle.x=obs.x
                        balle.y=obs.y
                        balle.rayon=balle.rayon-1
            if balle.vx!=0 and balle.vy!=0:
                for balle2 in self.Liste:
                    condition=sqrt(((balle.x-balle2.x)**2)+((balle.y-balle2.y)**2))
                    if balle.x!=balle2.x and balle.y!=balle2.y:
                        for verifier in range(len(verification)):
                            if condition==verification[verifier]:
                                Ok=0
                        conditioncolision=(condition<=balle.rayon+balle2.rayon)
                        ##Calcul des variables après la collision
                        if conditioncolision and Ok==1:
                            X=balle.x
                            Y=balle.y
                            XR=balle2.x
                            YR=balle2.y
                            DX=balle.vx
                            DY=balle.vy
                            DXR=balle2.vx
                            DYR=balle2.vy
                            RAYON=15
                            ##Calcul lorsque les balles bougent
                            if (DX!=0 or DY!=0) and (DYR==0 and DXR==0):
                                ## Calcul de la position exact de la balle durant l'impact
                                if DX!=0:
                                    m=(DY/DX)
                                    p=Y-(m*X)
                                    c=-(((2*RAYON)**2)-(XR**2)-(YR**2)+(2*p*YR)-((p)**2))
                                    a=1+(m**2)
                                    b=2*((m*(p-YR))-XR)
                                    delta=(b**2)-(4*c*a)
                                    if delta>=0:
                                        solution1=(((-b-(sqrt(delta))))/(2*a))
                                        solution2=(((-b+(sqrt(delta))))/(2*a))
                                        if DX<0:
                                            X=solution2
                                        if DX>0:
                                            X=solution1
                                        Y=(m*X)+p
                                        ##Calcul lorsque une balle bouge
                                F=Al_Kashi(X,(X+DX),Y,(Y+DY),X,XR,Y,YR,XR,(X+DX),YR,(Y+DY))
                                VitesseD=sqrt((DX**2) +(DY**2))
                                angleV2=Al_Kashi(X,XR,Y,YR,X,XR,Y,Y,XR,XR,YR,Y)
                                DXR=VitesseD*cos(F)*cos(angleV2)
                                DYR=VitesseD*cos(F)*sin(angleV2)
                                if XR<X and DXR>0:
                                    DXR=-DXR
                                if YR<Y and DYR>0:
                                    DYR=-DYR
                                DX=(DX-DXR)
                                DY=(DY-DYR)
                            else:
                                angle1=Al_Kashi(X,X-DX,Y,Y-DY,X,X-DX,Y,Y,X-DX,X-DX,Y-DY,Y)
                                angle2=Al_Kashi(XR,XR-DXR,YR,YR-DYR,XR,XR-DXR,YR,YR,XR-DXR,XR-DXR,YR-DYR,YR)
                                v1=sqrt((DX**2)+((DY)**2))
                                v2=sqrt((DXR**2)+((DYR)**2))
                                angle1_2=atan((v2/v1)*(sin(angle2)/cos(angle1)))
                                angle2_2=atan((v1/v2)*(sin(angle1)/cos(angle2)))
                                v1_2=sqrt(((v2*sin(angle2))**2)+((v1*cos(angle1))**2))
                                v2_2=sqrt(((v1*sin(angle1))**2)+((v2*cos(angle2))**2))
                                DX=v1_2*cos(angle1_2)
                                DY=v1_2*sin(angle1_2)
                                DXR=v2_2*cos(angle2_2)
                                DYR=v2_2*sin(angle2_2)
                                if X-XR<0:
                                    DX=-DX
                                if Y-YR<0:
                                    DY=-DY
                                if XR-X<0:
                                    DXR=-DXR
                                if YR-Y<0:
                                    DYR=-DYR

                            balle.x=X
                            balle.y=Y
                            balle2.x=XR
                            balle2.y=YR
                            balle.vx=DX
                            balle.vy=DY
                            balle2.vx=DXR
                            balle2.vy=DYR
                            condition=sqrt(((balle.x-balle2.x)**2)+((balle.y-balle2.y)**2))
                            verification+=[condition]

        self.Tir=True
        for balle in self.Liste:
            if balle.vx!=0 or balle.vy!=0:
                self.Tir=False
        X=self.pj.x
        Y=self.pj.y
        ## --- gestion des evenements
        for event in pygame.event.get():
            ##joueur quitte
            if event.type == pygame.QUIT:
                done = True
            if event.type == pygame.MOUSEMOTION:
                self.x=event.pos[0]
                self.y=event.pos[1]
                x=self.x
                y=self.y
                can_angle=Al_Kashi(X,x,Y,y,X,x,Y,Y,x,x,y,Y)
                ecart=(1/36)*math.pi
                ecart2=(1/144)*math.pi
                if y<Y:
                    can_angle=-can_angle
                    ecart=-ecart
                    if x<X:
                        can_angle=-math.pi-can_angle
                elif x<X:
                    can_angle=math.pi-can_angle
                can_angle_1=can_angle-ecart
                can_angle_2=can_angle+ecart
                can_angle_3=can_angle-ecart2
                can_angle_4=can_angle+ecart2
                D1=40
                D2=400
                self.x_1=X+D1*cos(can_angle_1)
                self.y_1=Y+D1*sin(can_angle_1)
                self.x_2=X+D1*cos(can_angle_2)
                self.y_2=Y+D1*sin(can_angle_2)
                self.x_3=X+D2*cos(can_angle_3)
                self.y_3=Y+D2*sin(can_angle_3)
                self.x_4=X+D2*cos(can_angle_4)
                self.y_4=Y+D2*sin(can_angle_4)
                if y>Y:
                    x1=self.x_1
                    y1=self.y_1
                    self.x_1=self.x_2
                    self.y_1=self.y_2
                    self.x_2=x1
                    self.y_2=y1
            if self.Tir:
                if event.type == pygame.MOUSEBUTTONDOWN and event.button == 1:
                    X=self.pj.x
                    Y=self.pj.y
                    X2=event.pos[0]
                    Y2=event.pos[1]
                    angle=Al_Kashi(X,X2,Y,Y2,X,X2,Y,Y,X2,X2,Y2,Y)
                    v=50
                    vx=v*cos(angle)
                    vy=v*sin(angle)
                    if X2>X and vx>0:
                        vx=-vx
                    if Y2>Y and vy>0:
                        vy=-vy
                    self.pj.vx=vx
                    self.pj.vy=vy

    def dessiner(self):
        WHITE = (0xFF, 0xFF, 0xFF)
        RED = (0xFD, 0x01, 0x01)
        BLUE = (0x00, 0x00, 0xFF)
        BLACK = (0x00, 0x00, 0x00)
        GREEN = (0x3A, 0x9D, 0x23)
        GREENH = (0x1B, 0x4F, 0x08)
        BRUNFoncé=(0x5B,0x3C,0x11)
        BRUN = (0x74, 0x35, 0x03)
        YELLOW = (0xFE, 0xFE,0x01)
        
        listecouleur=[WHITE,BLACK]
        for i in range (7):
            listecouleur+=[RED]
        for i in range (7):
            listecouleur+=[YELLOW]
        screen.fill(BRUN)

        ##dessin obstacle
        pygame.draw.rect(screen,GREEN,(20,20,L-40,H-40))
        pygame.draw.line(screen,WHITE,(L*(3/4),20),(L*(3/4),H-20))
        pygame.draw.arc(screen,WHITE,(L*(3/4)-100,(H/2)-100,200,200),(-1/2*math.pi),(1/2*math.pi))
        def DN(Y):
            D=25
            X=25
            pygame.draw.circle(screen,BLACK,(int(X),int(Y)),D)
            X=975
            pygame.draw.circle(screen,BLACK,(int(X),int(Y)),D)
            X=L/2
            pygame.draw.circle(screen,BLACK,(int(X),int(Y)),D)
        def Bord(D,X1,X2):
            pygame.draw.polygon(screen,GREENH,((X1,D),(X2,D+20),(X2,H-D-20),(X1,H-D)))
        def Bord2(D,X1,X2):
            pygame.draw.polygon(screen,GREENH,((D,X1),(D+20,X2),(L/2-(D/2)-20,X2),(L/2-(D/2),X1)))
            pygame.draw.polygon(screen,GREENH,((L-D,X1),(L-D-20,X2),(L/2+(D/2)+20,X2),(L/2+(D/2),X1)))

        D=50
        Bord(D,20,30)
        Bord(D,L-20,L-30)
        Bord2(D,20,30)
        Bord2(D,H-20,H-30)
        DN(25)
        DN(475)

        ##dessin personnage
        collision=False
        res=[]
        for obs in self.obstacles:
            res=self.pj.collision(obs)
            if (res):
                collision=True
        compteur=0
        for balle in self.Liste:
            rayon=balle.rayon
            if rayon>1:
                pygame.draw.circle(screen,listecouleur[compteur],(int(balle.x),int(balle.y)),rayon)
            else:
                balle.vx=0
                balle.vy=0
            compteur+=1
        if self.pj.rayon<1 and self.Tir==True:
            self.pj=Personnage(350,100,0,1,0,0)
            self.Liste=[self.pj,self.ba,self.bb,self.bc,self.bd,self.be,self.bf,self.bg,self.bh,self.bi,self.bj,self.bk,self.bl,self.bm,self.bn,self.bo]
        if self.Tir:
            pygame.draw.polygon(screen,BRUNFoncé,((self.x_1,self.y_1),(self.x_2,self.y_2),(self.x_3,self.y_3),(self.x_4,self.y_4)))
def Al_Kashi(Xa1,Xa2,Ya1,Ya2,Xb1,Xb2,Yb1,Yb2,Xc1,Xc2,Yc1,Yc2):
    ##Calcul d'un angle à partir de 3 points
    fA = sqrt((Xa1-Xa2)**2 + (Ya1-Ya2)**2)
    fB = sqrt((Xb1-Xb2)**2 + (Yb1-Yb2)**2)
    fC = sqrt((Xc1-Xc2)**2 + (Yc1-Yc2)**2)
    if fA==0:
        fA=1/100
    if fB==0:
        fB=1/100
    E=((fA**2) + (fB**2) - (fC**2)) / (2*fA*fB)
    if E>1:
        E=1
    elif E<-1:
        E=-1
    QS=acos(E)
    return QS


def Jeu_Du_8():
    global done
    pygame.init()
    size = (L,H)

    screen1 = pygame.display.set_mode(size)
    pygame.display.set_caption("Jeu de 8")


    ##boolean boucle
    done = False
    ##creation du jeu

    jeu=Jeu()

    ##Musique en jeu
    music = pygame.mixer.music.load("BirdBrainz_II.wav")
    pygame.mixer.music.play()

    ##gestion horloge
    clock = pygame.time.Clock()
    ## -------- boucle principale
    while not done:



        ## --- evolution du jeu
        jeu.evoluer()

        ## --- affichage
        jeu.dessiner(screen1)

        ## --- mise a jour graphique
        pygame.display.flip()
        ## --- attente
        clock.tick(60)
    pygame.quit()
